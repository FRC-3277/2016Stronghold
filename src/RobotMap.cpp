// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


std::shared_ptr<CANTalon> RobotMap::driveTrainCANTalonLeft;
std::shared_ptr<CANTalon> RobotMap::driveTrainCANTalonRight;
std::shared_ptr<RobotDrive> RobotMap::driveTrainRobotDrive21;

std::shared_ptr<CANTalon> RobotMap::armExtendCANTalon;
std::shared_ptr<CANTalon> RobotMap::armLinearActuatorCANTalon;
std::shared_ptr<CANTalon> RobotMap::armWinchCANTalon1;
std::shared_ptr<CANTalon> RobotMap::armWinchCANTalon2;
std::shared_ptr<Relay> RobotMap::armRatchet;

std::shared_ptr<CANTalon> RobotMap::boulderBlasterCANTalon;

std::shared_ptr<Servo> RobotMap::camraPanServo;
std::shared_ptr<Servo> RobotMap::camraTiltServo;

std::shared_ptr<DigitalInput> RobotMap::Switch0;
std::shared_ptr<DigitalInput> RobotMap::Switch1;
std::shared_ptr<DigitalInput> RobotMap::Switch2;
std::shared_ptr<DigitalInput> RobotMap::Switch3;
std::shared_ptr<DigitalInput> RobotMap::Switch4;
std::shared_ptr<DigitalInput> RobotMap::Switch5;
std::shared_ptr<DigitalInput> RobotMap::Switch6;
std::shared_ptr<DigitalInput> RobotMap::Switch7;
std::shared_ptr<DigitalInput> RobotMap::Switch8;
std::shared_ptr<DigitalInput> RobotMap::Switch9;

void RobotMap::init() {
    LiveWindow *lw = LiveWindow::GetInstance();

    driveTrainCANTalonLeft.reset(new CANTalon(CAN_ID_DRIVE_LEFT_TALON));
    lw->AddActuator("DriveTrain", "CAN Talon Left", driveTrainCANTalonLeft);
    driveTrainCANTalonLeft.get()->SetInverted(true);
    
    driveTrainCANTalonRight.reset(new CANTalon(CAN_ID_DRIVE_LEFT_TALON));
    lw->AddActuator("DriveTrain", "CAN Talon Right", driveTrainCANTalonRight);
    driveTrainCANTalonRight.get()->SetInverted(true);

	driveTrainRobotDrive21.reset(new RobotDrive(
			driveTrainCANTalonLeft,
			driveTrainCANTalonRight));
		driveTrainRobotDrive21->SetSafetyEnabled(true);
        driveTrainRobotDrive21->SetExpiration(0.1);
        driveTrainRobotDrive21->SetSensitivity(0.5);
        driveTrainRobotDrive21->SetMaxOutput(1.0);

    armExtendCANTalon.reset(new CANTalon(CAN_ID_ARM_EXTEND_TALON));
    lw->AddActuator("Lifter", "CAN Lifter", armExtendCANTalon);

    armLinearActuatorCANTalon.reset(new CANTalon(CAN_ID_ARM_LINEAR_ACTUATOR_TALON));
    lw->AddActuator("Lifter", "CAN arm", armLinearActuatorCANTalon);

    armWinchCANTalon1.reset(new CANTalon(CAN_ID_ARM_WINCH_1_TALON));
	lw->AddActuator("Lifter", "CAN arm", armWinchCANTalon1);

	armWinchCANTalon2.reset(new CANTalon(CAN_ID_ARM_WINCH_1_TALON));
	lw->AddActuator("Lifter", "CAN arm", armWinchCANTalon2);

	armRatchet.reset(new Relay(0, Relay::kForwardOnly));
	lw->AddActuator("Lifter", "Ratchet", armRatchet);

	Switch0.reset(new DigitalInput(0));
	Switch1.reset(new DigitalInput(1));
	Switch2.reset(new DigitalInput(2));
	Switch3.reset(new DigitalInput(3));
	Switch4.reset(new DigitalInput(4));
	Switch5.reset(new DigitalInput(5));
	Switch6.reset(new DigitalInput(6));
	Switch7.reset(new DigitalInput(7));
	Switch8.reset(new DigitalInput(8));
	Switch9.reset(new DigitalInput(9));

	camraPanServo.reset(new Servo(9));
	camraTiltServo.reset(new Servo(8));

    boulderBlasterCANTalon.reset(new CANTalon(7));
    lw->AddActuator("BoulderBlaster", "CAN BoulderBlaster", boulderBlasterCANTalon);
}
